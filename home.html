<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>üíñ My Apology</title>
  <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet" />
  <style>
    /* Global styles */
    body {
      margin: 0;
      font-family: 'Pacifico', cursive;
      background: linear-gradient(135deg, #e7608c 0%, #f9ccd3 100%);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      color: #7b2ff7;
      overflow-x: hidden;
      justify-content: center;
      align-items: center;
    }
    header {
      padding: 1.5rem 1rem 0.3rem 1rem;
      text-align: center;
      text-shadow: 0 1px 5px rgba(255,105,135,0.8);
      user-select: none;
    }
    header h1 {
      margin: 0;
      font-size: 2.75rem;
      color: #e92e57;
    }
    header p {
      font-size: 1.3rem;
      margin-top: 0.25rem;
      color: #ff7b9c;
      font-weight: 500;
    }
    #scene {
      width: 90vw;
      max-width: 600px;
      height: 65vh;
      max-height: 600px;
      border-radius: 25px;
      box-shadow: 0 10px 30px rgba(231, 27, 64, 0.3);
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      position: relative;
      margin: 1rem auto;
      cursor: pointer;
      transition: box-shadow 0.3s ease;
    }
    #scene:hover {
      box-shadow: 0 15px 45px rgba(231, 27, 64, 0.5);
    }
    #messageBox {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      background: #ff4d6d;
      color: white;
      padding: 0.85rem 1.6rem;
      border-radius: 45px;
      font-size: 1.1rem;
      font-weight: 700;
      text-shadow: 0 0 4px #720027;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.4s ease;
      z-index: 10;
      user-select: none;
      box-shadow: 0 0 15px #ff4d6d;
    }
    footer {
      padding: 1rem;
      text-align: center;
      font-weight: 600;
      font-size: 1rem;
      color: #d6336c;
      user-select: none;
      text-shadow: 0 0 6px #ff527a;
      margin-top: auto;
    }
    /* Responsive typography */
    @media (max-width: 600px) {
      header h1 {
        font-size: 1.9rem;
      }
      header p {
        font-size: 1rem;
      }
      #scene {
        height: 50vh;
        max-height: 400px;
        width: 95vw;
      }
      footer {
        font-size: 0.9rem;
      }
    }
    @media (max-height: 500px) {
      #scene {
        height: 40vh;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header>
    <h1>üíñ A Message Just For You üíñ</h1>
    <p>Tap or click a floating heart to see my message.</p>
  </header>

  <!-- 3D Scene Container -->
  <div id="scene"></div>

  <!-- Message Box -->
  <div id="messageBox"></div>

  <!-- Footer -->
  <footer>
    <p>Made with ‚ù§Ô∏è by  Vinit üòì</p>
  </footer>

  <!-- Three.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>

  <script>
    (() => {
      const container = document.getElementById('scene');
      const messageBox = document.getElementById('messageBox');
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.z = 8;

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setClearColor(0x000000, 0); // transparent bg
      container.appendChild(renderer.domElement);

      // Handle resize
      function onWindowResize() {
        const width = container.clientWidth;
        const height = container.clientHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      }
      window.addEventListener('resize', onWindowResize);
      onWindowResize();

      // Heart shape creator
      function createHeartMesh() {
        const x = 0, y = 0;
        const heartShape = new THREE.Shape();
        heartShape.moveTo(x + 0.25, y + 0.25);
        heartShape.bezierCurveTo(x + 0.25, y + 0.25, x, y, x - 0.25, y);
        heartShape.bezierCurveTo(x - 1, y, x - 1, y + 0.75, x - 1, y + 0.75);
        heartShape.bezierCurveTo(x - 1, y + 1.25, x - 0.5, y + 1.75, x + 0.25, y + 2.25);
        heartShape.bezierCurveTo(x + 1, y + 1.75, x + 1.5, y + 1.25, x + 1.5, y + 0.75);
        heartShape.bezierCurveTo(x + 1.5, y + 0.75, x + 1.5, y, x + 0.75, y);
        heartShape.bezierCurveTo(x + 0.5, y, x + 0.25, y + 0.25, x + 0.25, y + 0.25);

        const geometry = new THREE.ShapeGeometry(heartShape);
        const material = new THREE.MeshPhongMaterial({
          color: 0xff4567,
          shininess: 120,
          specular: 0xff81ac
        });
        return new THREE.Mesh(geometry, material);
      }

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xff6688, 0.9);
      directionalLight.position.set(5, 10, 7);
      scene.add(directionalLight);

      // Hearts array
      const hearts = [];
      const heartCount = 8;

      // Raycaster for interaction
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      // Create hearts with extra properties for heartbeat and floating
      for(let i = 0; i < heartCount; i++) {
        const heart = createHeartMesh();
        heart.position.x = (Math.random() - 0.5) * 8;
        heart.position.y = (Math.random() - 0.5) * 6;
        heart.position.z = (Math.random() - 0.5) * 4;
        const baseScale = 0.75 + Math.random() * 0.7;
        heart.scale.set(baseScale, baseScale, baseScale);
        scene.add(heart);
        hearts.push({
          mesh: heart,
          baseScale,
          speed: 0.0012 + Math.random() * 0.0016,
          direction: Math.random() > 0.5 ? 1 : -1,
          floatAmplitude: 0.06 + Math.random() * 0.06,
          floatOffset: Math.random() * Math.PI * 2,
          pulsePhase: Math.random() * 2 * Math.PI,
        });
      }

      const clock = new THREE.Clock();

      // Show message box with fade
      function showMessage(text) {
        messageBox.textContent = text;
        messageBox.style.opacity = '1';
        setTimeout(() => {
          messageBox.style.opacity = '0';
        }, 3000);
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        const elapsed = clock.getElapsedTime();

        hearts.forEach(({ mesh, baseScale, speed, direction, floatAmplitude, floatOffset, pulsePhase }, i) => {
          // Floating up/down
          mesh.position.y += Math.sin(elapsed * 2 + floatOffset) * 0.002;

          // Pulse scale (heartbeat)
          const scalePulse = baseScale + Math.sin(elapsed * 5 + pulsePhase) * 0.1;
          mesh.scale.set(scalePulse, scalePulse, scalePulse);

          // Rotation for floating effect
          mesh.rotation.z += speed * direction;
          mesh.rotation.x += speed * 0.5 * direction;
          mesh.rotation.y += speed * 0.7 * direction;
        });

        renderer.render(scene, camera);
      }
      animate();

      // Detect click and raycast
      container.addEventListener('click', event => {
        const rect = container.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(hearts.map(h => h.mesh));
        if(intersects.length > 0){
          showMessage('üíå The message is: Always keep love in your heart! üíñ');
        }
      });
    })();
  </script>
</body>
</html>
